# --- File: idc_engine.py ---

"""
idc_engine.py: Parses and executes IDA-compatible IDC scripts to override auto-analysis.
This version has a robust grammar to handle complex IDC files generated by IDA,
including C-style expressions, control flow, and function definitions.
"""

import logging
import os
import re
from lark import Lark, Transformer
from database import (
    AnalysisDatabase, ITEM_TYPE_CODE, ITEM_TYPE_DATA, DATA_TYPE_ASCII,
    DATA_TYPE_BYTE, DATA_TYPE_WORD, DATA_TYPE_DWORD,
    Segment, Function, OperandFormat
)

logger = logging.getLogger(__name__)

# A robust grammar based on the provided IDC specification. It can parse
# C-style expressions, control flow, and function definitions to reliably
# extract the low-level API calls we need to execute.
idc_grammar = r"""
    ?start: item*

    ?item: statement
         | function_definition
         | preprocessor -> ignore
         | declaration

    preprocessor: /#.*/
    declaration: ("auto" | "extern") CNAME ("=" expr)? ";" -> ignore

    function_definition: "static" CNAME "(" [parameters] ")" block
    parameters: (parameter ("," parameter)*)?
    parameter: CNAME

    block: "{" item* "}"

    ?statement: if_statement
              | for_statement
              | while_statement
              | do_while_statement
              | return_statement
              | break_statement
              | continue_statement
              | try_statement
              | throw_statement
              | empty_statement
              | expr_statement

    expr_statement: expr ";"
    if_statement: "if" "(" expr ")" statement ["else" statement]
    for_statement: "for" "(" expr_statement expr_statement expr? ")" statement
    while_statement: "while" "(" expr ")" statement
    do_while_statement: "do" statement "while" "(" expr ")" ";"
    return_statement: "return" [expr] ";" -> ignore
    break_statement: "break" ";" -> ignore
    continue_statement: "continue" ";" -> ignore
    try_statement: "try" statement "catch" "(" CNAME ")" statement -> ignore
    throw_statement: "throw" expr ";" -> ignore
    empty_statement: ";" -> ignore

    ?expr: assign_expr
    ?assign_expr: ternary_expr ("=" assign_expr)?
    ?ternary_expr: logical_or_expr ["?" expr ":" ternary_expr]
    ?logical_or_expr: logical_and_expr ("||" logical_and_expr)*
    ?logical_and_expr: bitwise_or_expr ("&&" bitwise_or_expr)*
    ?bitwise_or_expr: bitwise_xor_expr ("|" bitwise_xor_expr)*
    ?bitwise_xor_expr: bitwise_and_expr ("^" bitwise_and_expr)*
    ?bitwise_and_expr: equality_expr ("&" equality_expr)*
    ?equality_expr: relational_expr (("==" | "!=") relational_expr)*
    ?relational_expr: shift_expr (("<" | ">" | "<=" | ">=") shift_expr)*
    ?shift_expr: additive_expr (("<<" | ">>") additive_expr)*
    ?additive_expr: multiplicative_expr (("+" | "-") multiplicative_expr)*
    ?multiplicative_expr: unary_expr (("*" | "/" | "%") unary_expr)*
    ?unary_expr: ("!" | "~" | "&")* atom

    ?atom: literal
         | CNAME -> identifier
         | "(" expr ")"
         | call_expr

    call_expr: CNAME "(" [arguments] ")"
    arguments: (expr ("," expr)*)?

    ?literal: HEX_NUMBER -> number
            | SIGNED_INT -> number
            | ESCAPED_STRING -> string

    HEX_NUMBER: /0[xX][0-9a-fA-F]+/

    %import common.CNAME
    %import common.SIGNED_INT
    %import common.ESCAPED_STRING
    %import common.WS
    %ignore WS
    %ignore /\/\/[^\n]*/
    %ignore /\/\*(\*(?!\/)|[^*])*\*\//
"""

class IDCTransformer(Transformer):
    """
    Transforms the Lark parse tree. It recursively finds all function calls
    ('call_expr' nodes) and returns them as a flat list, discarding all other
    structural and expression-related elements.
    """
    def __init__(self):
        self.statements = []

    def number(self, n):
        return int(n, 0)

    def string(self, s):
        return s[1:-1].encode('latin-1').decode('unicode_escape')

    def identifier(self, i):
        return str(i)

    def arguments(self, *args):
        return list(args)

    def call_expr(self, func_name, args=None):
        statement_tuple = (str(func_name), args or [])
        self.statements.append(statement_tuple)
        return statement_tuple

    # Default handler for all other rules: traverse children and collect results.
    def __default__(self, data, children, meta):
        # This is a simple way to visit all nodes recursively.
        # We don't need to do anything with the results other than
        # letting the traversal continue down to the `call_expr` nodes.
        # Return children if they exist, otherwise return data
        if children:
            return children
        return data

    def start(self, items):
        # After the entire tree is walked, self.statements will be populated.
        return self.statements

class IDCScriptEngine:
    def __init__(self, db: AnalysisDatabase):
        self.db = db
        self.parser = Lark(idc_grammar, start='start', parser='lalr', transformer=IDCTransformer())
        self.function_map = self._initialize_function_map()

    def _initialize_function_map(self):
        return {
            "create_insn": self.idc_create_insn, "create_byte": lambda a: self.idc_create_data(a, 1),
            "create_word": lambda a: self.idc_create_data(a, 2), "create_dword": lambda a: self.idc_create_data(a, 4),
            "create_strlit": self.idc_create_ascii, "set_name": self.idc_set_name, "set_cmt": self.idc_set_cmt,
            "add_func": self.idc_add_func, "op_hex": lambda a, n: self.idc_op_format(a, n, 'hex'),
            "op_dec": lambda a, n: self.idc_op_format(a, n, 'dec'), "op_offset": self.idc_op_offset,
            "op_plain_offset": self.idc_op_offset, "add_segm_ex": self.idc_add_segm_ex,
            # --- Comprehensive list of No-Op functions ---
            "update_extra_cmt": self.idc_no_op, "set_frame_size": self.idc_no_op, "define_local_var": self.idc_no_op,
            "op_enum": self.idc_no_op, "op_stroff": self.idc_no_op, "op_stkvar": self.idc_no_op,
            "op_seg": self.idc_no_op, "SegRename": self.idc_no_op, "SegClass": self.idc_no_op,
            "SegDefReg": self.idc_no_op, "set_segm_type": self.idc_no_op, "split_sreg_range": self.idc_no_op,
            "delete_all_segments": self.idc_no_op, "add_enum": self.idc_no_op, "add_enum_member": self.idc_no_op,
            "add_struc": self.idc_no_op, "add_struc_member": self.idc_no_op, "get_struc_id": self.idc_no_op,
            "get_member_id": self.idc_no_op, "SetType": self.idc_no_op, "set_struc_align": self.idc_no_op,
            "set_processor_type": self.idc_no_op, "set_inf_attr": self.idc_no_op, "set_flag": self.idc_no_op,
            "add_default_til": self.idc_no_op, "begin_type_updating": self.idc_no_op, "end_type_updating": self.idc_no_op,
            "make_array": self.idc_no_op, "get_inf_attr": self.idc_no_op, "GetEnum": self.idc_no_op,
        }

    def idc_no_op(self, *args, **kwargs):
        return 0 # Return a dummy value for expressions

    def execute_script(self, filepath: str):
        logger.info(f"Executing IDC script: {filepath}")
        try:
            # Check file size first
            file_size = os.path.getsize(filepath)
            if file_size > 10000:  # If file is larger than 10KB, process in chunks
                logger.warning(f"Large IDC file detected ({file_size} bytes). Processing in chunks...")
                self._process_large_idc_file(filepath)
                return

            with open(filepath, 'r', encoding='latin-1') as f:
                content = f.read()

            logger.debug(f"IDC script content (first 100 chars): {content[:100]}")

            # Parse the content and handle any parse errors
            try:
                logger.debug("Starting IDC script parsing...")
                # The transformer is now part of the Lark instance
                parse_tree = self.parser.parse(content)
                logger.debug(f"Parse tree type: {type(parse_tree)}")

                # If the result is a list (from the start rule), use it directly
                if isinstance(parse_tree, list):
                    statements = parse_tree
                    logger.debug("Parse tree is a list, using directly")
                # If it's a Tree object, extract the children
                elif hasattr(parse_tree, 'children'):
                    logger.debug("Parse tree has children attribute")
                    statements = parse_tree.children if parse_tree.children else []
                else:
                    # Handle other cases
                    logger.debug(f"Parse tree is neither list nor has children. Type: {type(parse_tree)}")
                    statements = [parse_tree] if parse_tree else []

                logger.info(f"Found and parsed {len(statements)} function calls in IDC script.")

                for i, item in enumerate(statements):
                    logger.debug(f"Processing statement {i+1}: {item}")

                    # Skip if not a tuple or doesn't have expected structure
                    if not isinstance(item, tuple) or len(item) < 2:
                        logger.debug(f"Skipping non-tuple or malformed statement: {item}")
                        continue

                    func_name, args = item

                    if func_name in self.function_map:
                        # Filter out nested call results from argument lists
                        clean_args = [arg for arg in args if not isinstance(arg, tuple)]
                        try:
                            logger.debug(f"Executing {func_name} with args: {clean_args}")
                            self.function_map[func_name](*clean_args)
                        except TypeError:
                            logger.warning(f"IDC Warning (call {i+1}): Incorrect arguments for '{func_name}'. Have {clean_args}. Skipping.")
                        except Exception as e:
                            logger.warning(f"IDC Warning (call {i+1}): Runtime error in '{func_name}': {e}. Skipping.")
                    else:
                        logger.debug(f"Function {func_name} not in function map. Available functions: {list(self.function_map.keys())}")
            except Exception as parse_error:
                logger.error(f"Error during IDC script parsing: {parse_error}")
                import traceback
                logger.error(f"Traceback: {traceback.format_exc()}")
                raise
        except Exception as e:
            logger.error(f"Fatal error parsing IDC script: {e}")
            import traceback
            logger.error(f"Traceback: {traceback.format_exc()}")

    def _process_large_idc_file(self, filepath):
        """Process a large IDC file in chunks to avoid memory issues."""
        import os
        import os
        import re

        # Simple regex to match function calls like create_byte(0x1234);
        func_call_pattern = re.compile(r'(\w+)\(([^)]*)\);')

        logger.info(f"Processing large IDC file: {filepath}")

        with open(filepath, 'r', encoding='latin-1') as f:
            line_number = 0
            for line in f:
                line_number += 1
                # Skip comments and empty lines
                if line.strip().startswith(('//', '#', '/*')) or not line.strip():
                    continue

                # Look for function calls in the line
                for match in func_call_pattern.finditer(line):
                    func_name = match.group(1)
                    args_str = match.group(2)

                    # Skip functions we don't handle
                    if func_name not in self.function_map:
                        continue

                    # Parse arguments (simple comma-separated values)
                    args = []
                    for arg_str in [a.strip() for a in args_str.split(',') if a.strip()]:
                        # Handle different argument types
                        if arg_str.startswith(('0x', '0X')):
                            # Hex number
                            args.append(int(arg_str, 16))
                        elif arg_str.isdigit() or (arg_str.startswith('-') and arg_str[1:].isdigit()):
                            # Decimal number
                            args.append(int(arg_str))
                        elif arg_str.startswith('"') and arg_str.endswith('"'):
                            # String literal
                            args.append(arg_str[1:-1])
                        else:
                            # Assume it's a variable name or other identifier
                            args.append(arg_str)

                    try:
                        logger.debug(f"Executing {func_name} with args: {args}")
                        self.function_map[func_name](*args)
                    except TypeError:
                        logger.warning(f"IDC Warning (line {line_number}): Incorrect arguments for '{func_name}'. Have {args}. Skipping.")
                    except Exception as e:
                        logger.warning(f"IDC Warning (line {line_number}): Runtime error in '{func_name}': {e}. Skipping.")

    def idc_create_insn(self, addr):
        info = self.db.get_address_info(addr)
        if info: info.item_type = ITEM_TYPE_CODE

    def idc_create_data(self, addr, size):
        for i in range(size):
            info = self.db.get_address_info(addr + i)
            if info:
                info.item_type = ITEM_TYPE_DATA
                if i == 0:
                    info.item_size = size
                    if size == 4: info.data_type = DATA_TYPE_DWORD
                    elif size == 2: info.data_type = DATA_TYPE_WORD
                    else: info.data_type = DATA_TYPE_BYTE

    def idc_create_ascii(self, addr, length):
        if length == 0:
            curr_addr, length = addr, 0
            while True:
                info = self.db.get_address_info(curr_addr)
                length += 1
                if not info or info.byte_value == 0: break
                curr_addr += 1
        
        info = self.db.get_address_info(addr)
        if info:
            info.item_type = ITEM_TYPE_DATA
            info.item_size = length
            info.data_type = DATA_TYPE_ASCII
        
        for i in range(1, length):
            info_rest = self.db.get_address_info(addr + i)
            if info_rest:
                info_rest.item_type = ITEM_TYPE_DATA
                info_rest.data_type = DATA_TYPE_ASCII

    def idc_set_name(self, addr, name):
        info = self.db.get_address_info(addr)
        if info: info.label = name

    def idc_set_cmt(self, addr, comment, repeatable):
        info = self.db.get_address_info(addr)
        if info:
            if repeatable: info.repeatable_comment = comment
            else: info.comment = comment

    def idc_op_format(self, addr, op_index, fmt_type):
        self.db.operand_format_overrides[(addr, op_index)] = OperandFormat(format_type=fmt_type)

    def idc_op_offset(self, addr, op_index, base):
        self.db.operand_format_overrides[(addr, op_index)] = OperandFormat(format_type='offset', value=base)

    def idc_add_func(self, start_addr, end_addr):
        self.db.add_function(start_addr, end_addr)

    def idc_add_segm_ex(self, start, end, base, use32, name, sclass, *args):
        selector = base
        # Ensure sclass is always a string
        seg_class_str = str(sclass) if sclass is not None else "CODE"
        new_seg = Segment(name, start, end, selector, seg_class_str, bool(use32))
        if not self.db.get_segment_by_selector(selector):
            self.db.segments.append(new_seg)