# --- File: idc_engine.py ---

"""
idc_engine.py: Parses and executes IDA-compatible IDC scripts to override auto-analysis.
This version has a robust grammar to handle complex IDC files generated by IDA,
including C-style expressions, control flow, and function definitions.
"""

import logging
import os
import re
from lark import Lark, Transformer, v_args
from database import (
    AnalysisDatabase, ITEM_TYPE_CODE, ITEM_TYPE_DATA, DATA_TYPE_ASCII,
    DATA_TYPE_BYTE, DATA_TYPE_WORD, DATA_TYPE_DWORD,
    Segment, Function, OperandFormat
)

logger = logging.getLogger(__name__)

idc_grammar = r"""
    ?start: item*

    ?item: statement
         | function_definition
         | preprocessor -> ignore
         | declaration

    preprocessor: /#.*/
    declaration: ("auto" | "extern") CNAME ("=" expr)? ";" -> ignore

    function_definition: "static" CNAME "(" [parameters] ")" block
    parameters: (parameter ("," parameter)*)?
    parameter: CNAME

    block: "{" item* "}"

    ?statement: if_statement
              | for_statement
              | while_statement
              | do_while_statement
              | return_statement
              | break_statement
              | continue_statement
              | try_statement
              | throw_statement
              | empty_statement
              | expr_statement

    expr_statement: expr ";"
    if_statement: "if" "(" expr ")" statement ["else" statement] -> ignore
    for_statement: "for" "(" expr_statement expr_statement expr? ")" statement -> ignore
    while_statement: "while" "(" expr ")" statement -> ignore
    do_while_statement: "do" statement "while" "(" expr ")" ";" -> ignore
    return_statement: "return" [expr] ";" -> ignore
    break_statement: "break" ";" -> ignore
    continue_statement: "continue" ";" -> ignore
    try_statement: "try" statement "catch" "(" CNAME ")" statement -> ignore
    throw_statement: "throw" expr ";" -> ignore
    empty_statement: ";" -> ignore

    ?expr: assignment | ternary_expr
    assignment: CNAME "=" expr

    ?ternary_expr: logical_or_expr ("?" expr ":" ternary_expr)*
    ?logical_or_expr: logical_and_expr ("||" logical_and_expr)*
    ?logical_and_expr: bitwise_or_expr ("&&" bitwise_or_expr)*
    ?bitwise_or_expr: bitwise_xor_expr ("|" bitwise_xor_expr)*
    ?bitwise_xor_expr: bitwise_and_expr ("^" bitwise_and_expr)*
    ?bitwise_and_expr: equality_expr ("&" equality_expr)*
    ?equality_expr: relational_expr (("==" | "!=") relational_expr)*
    ?relational_expr: shift_expr (("<" | ">" | "<=" | ">=") shift_expr)*
    ?shift_expr: additive_expr (("<<" | ">>") additive_expr)*
    ?additive_expr: multiplicative_expr (("+" | "-") multiplicative_expr)*
    ?multiplicative_expr: unary_expr (("*" | "/" | "%") unary_expr)*
    ?unary_expr: (unary_op)* atom
    unary_op: "!" | "~" | "&" | "-"

    ?atom: literal
         | CNAME -> identifier
         | "(" expr ")"
         | call_expr

    call_expr: CNAME "(" [arguments] ")"
    arguments: (expr ("," expr)*)?

    ?literal: HEX_NUMBER -> number
            | SIGNED_INT -> number
            | ESCAPED_STRING -> string

    HEX_NUMBER.2: /0[xX][0-9a-fA-F]+/

    %import common.CNAME
    %import common.SIGNED_INT
    %import common.ESCAPED_STRING
    %import common.WS

    %ignore WS
    %ignore /\/\/[^\n]*/
    %ignore /\/\*(\*(?!\/)|[^*])*\*\//
"""

class IDCTransformer(Transformer):
    def __init__(self):
        super().__init__()
        self.statements = []
        self.variables = {}

    def number(self, n): return int(n[0].value, 0)
    def string(self, s): return s[0].value[1:-1].encode('latin-1').decode('unicode_escape')
    def identifier(self, i): return self.variables.get(str(i[0].value), str(i[0].value))

    def assignment(self, items):
        var_name = str(items[0].value)
        value = items[2] # items are [var_token, '=', value]
        self.variables[var_name] = value
        return value

    def _reduce_ops(self, items):
        val = items[0]
        for i in range(1, len(items), 2):
            op = items[i].value
            right = items[i+1]
            if not isinstance(val, int) or not isinstance(right, int): continue
            if op == '+': val += right
            elif op == '-': val -= right
            elif op == '*': val *= right
            elif op == '/': val //= right if right != 0 else 0
            elif op == '|': val |= right
            elif op == '&': val &= right
            elif op == '^': val ^= right
            elif op == '<<': val <<= right
            elif op == '>>': val >>= right
        return val

    additive_expr = multiplicative_expr = bitwise_or_expr = bitwise_xor_expr = bitwise_and_expr = shift_expr = _reduce_ops

    def unary_expr(self, items):
        val = items[-1]
        for op in reversed(items[:-1]):
            if op.value == '-' and isinstance(val, int): val = -val
            if op.value == '~' and isinstance(val, int): val = ~val
        return val

    def arguments(self, args): return args
    
    def call_expr(self, items):
        func_name = str(items[0].value)
        args = items[1] if len(items) > 1 else []
        self.statements.append((func_name, args))
        if str(func_name) in ("add_struc", "add_enum", "get_struc_id", "GetEnum"): return -1
        return 0

    def start(self, items): return self.statements
    def __default__(self, data, children, meta):
        return children[0] if len(children) == 1 else children

class IDCScriptEngine:
    def __init__(self, db: AnalysisDatabase):
        self.db = db
        self.function_map = self._initialize_function_map()

    def _initialize_function_map(self):
        return {
            "create_insn": self.idc_create_insn, "create_byte": lambda a: self.idc_create_data(a, 1),
            "create_word": lambda a: self.idc_create_data(a, 2), "create_dword": lambda a: self.idc_create_data(a, 4),
            "create_strlit": self.idc_create_ascii, "set_name": self.idc_set_name, "set_cmt": self.idc_set_cmt,
            "add_func": self.idc_add_func, "op_hex": lambda a, n: self.idc_op_format(a, n, 'hex'),
            "op_dec": lambda a, n: self.idc_op_format(a, n, 'dec'), "op_offset": self.idc_op_offset,
            "op_plain_offset": self.idc_op_offset, "add_segm_ex": self.idc_add_segm_ex,
            **{k: self.idc_no_op for k in ["update_extra_cmt", "set_frame_size", "define_local_var", "op_enum",
            "op_stroff", "op_stkvar", "op_seg", "SegRename", "SegClass", "SegDefReg", "set_segm_type",
            "split_sreg_range", "delete_all_segments", "add_enum", "add_enum_member", "add_struc", "add_struc_member",
            "get_struc_id", "get_member_id", "SetType", "set_struc_align", "set_processor_type", "set_inf_attr",
            "set_flag", "add_default_til", "begin_type_updating", "end_type_updating", "make_array", "get_inf_attr", "GetEnum"]}
        }

    def idc_no_op(self, *args, **kwargs): return 0
    def idc_create_insn(self, addr):
        if not isinstance(addr, int): return
        if info := self.db.get_address_info(addr): info.item_type = ITEM_TYPE_CODE
    def idc_create_data(self, addr, size):
        if not isinstance(addr, int): return
        for i in range(size):
            if info := self.db.get_address_info(addr + i):
                info.item_type = ITEM_TYPE_DATA
                if i == 0:
                    info.item_size = size
                    if size == 4: info.data_type = DATA_TYPE_DWORD
                    elif size == 2: info.data_type = DATA_TYPE_WORD
                    elif size == 1: info.data_type = DATA_TYPE_BYTE
    def idc_create_ascii(self, addr, length=0):
        if not isinstance(addr, int): return
        if length == 0:
            curr_addr, length = addr, 0
            while True:
                info = self.db.get_address_info(curr_addr); length += 1
                if not info or info.byte_value == 0: break
                curr_addr += 1
        if info := self.db.get_address_info(addr):
            info.item_type, info.item_size, info.data_type = ITEM_TYPE_DATA, length, DATA_TYPE_ASCII
        for i in range(1, length):
            if info_rest := self.db.get_address_info(addr + i): info_rest.item_type, info_rest.data_type = ITEM_TYPE_DATA, DATA_TYPE_ASCII
    def idc_set_name(self, addr, name, *args):
        if not isinstance(addr, int): return
        if info := self.db.get_address_info(addr): info.label = name
    def idc_set_cmt(self, addr, comment, repeatable=0, *args):
        if not isinstance(addr, int): return
        is_repeatable = bool(int(repeatable)) if str(repeatable).isdigit() else False
        if info := self.db.get_address_info(addr):
            if is_repeatable: info.repeatable_comment = comment
            else: info.comment = comment
    def idc_op_format(self, addr, op_index, fmt_type):
        if not isinstance(addr, int): return
        self.db.operand_format_overrides[(addr, op_index)] = OperandFormat(fmt_type)
    def idc_op_offset(self, addr, op_index, base):
        if not isinstance(addr, int): return
        self.db.operand_format_overrides[(addr, op_index)] = OperandFormat('offset', base)
    def idc_add_func(self, start_addr, end_addr):
        if not isinstance(start_addr, int) or not isinstance(end_addr, int): return
        self.db.add_function(start_addr, end_addr)
    def idc_add_segm_ex(self, start, end, base, use32, name, sclass, *args):
        if not all(isinstance(i, int) for i in [start, end, base, use32]): return
        new_seg = Segment(name, start, end, base, str(sclass) if sclass else "CODE", bool(use32))
        if not self.db.get_segment_by_selector(base): self.db.segments.append(new_seg)

    def execute_script(self, filepath: str):
        logger.info(f"Executing IDC script: {filepath}")
        try:
            with open(filepath, 'r', encoding='latin-1') as f:
                script_content = f.read()
            
            script_content = re.sub(r'\b(x|id|mid)=', '', script_content)

            transformer = IDCTransformer()
            parser = Lark(idc_grammar, start='start', parser='lalr', transformer=transformer)
            statements = parser.parse(script_content)

            for func_name, args in statements:
                if func_name in self.function_map:
                    try:
                        self.function_map[func_name](*args)
                    except Exception as e:
                        logger.warning(
                            f"IDC Warning: Error executing '{func_name}({', '.join(map(str, args))})': {e}"
                        )
        except Exception as e:
            logger.error(f"Fatal error processing IDC script '{filepath}': {e}", exc_info=True)