# --- File: idc_engine.py ---

"""
idc_engine.py: Parses and executes IDA-compatible IDC scripts to override auto-analysis.
This version has a robust grammar to handle complex IDC files generated by IDA,
including C-style expressions, control flow, and function definitions.
"""

import logging
import os
import re
from lark import Lark, Transformer
from database import (
    AnalysisDatabase, ITEM_TYPE_CODE, ITEM_TYPE_DATA, DATA_TYPE_ASCII,
    DATA_TYPE_BYTE, DATA_TYPE_WORD, DATA_TYPE_DWORD,
    Segment, Function, OperandFormat
)

logger = logging.getLogger(__name__)

# A robust grammar based on the provided IDC specification. It can parse
# C-style expressions, control flow, and function definitions to reliably
# extract the low-level API calls we need to execute.
idc_grammar = r"""
    ?start: item*

    ?item: statement
         | function_definition
         | preprocessor -> ignore
         | declaration

    preprocessor: /#.*/
    declaration: ("auto" | "extern") CNAME ("=" expr)? ";" -> ignore

    function_definition: "static" CNAME "(" [parameters] ")" block
    parameters: (parameter ("," parameter)*)?
    parameter: CNAME

    block: "{" item* "}"

    ?statement: if_statement
              | for_statement
              | while_statement
              | do_while_statement
              | return_statement
              | break_statement
              | continue_statement
              | try_statement
              | throw_statement
              | empty_statement
              | expr_statement

    expr_statement: expr ";"
    if_statement: "if" "(" expr ")" statement ["else" statement]
    for_statement: "for" "(" expr_statement expr_statement expr? ")" statement
    while_statement: "while" "(" expr ")" statement
    do_while_statement: "do" statement "while" "(" expr ")" ";"
    return_statement: "return" [expr] ";" -> ignore
    break_statement: "break" ";" -> ignore
    continue_statement: "continue" ";" -> ignore
    try_statement: "try" statement "catch" "(" CNAME ")" statement -> ignore
    throw_statement: "throw" expr ";" -> ignore
    empty_statement: ";" -> ignore

    ?expr: assign_expr
    ?assign_expr: ternary_expr ("=" assign_expr)?
    ?ternary_expr: logical_or_expr ["?" expr ":" ternary_expr]
    ?logical_or_expr: logical_and_expr ("||" logical_and_expr)*
    ?logical_and_expr: bitwise_or_expr ("&&" bitwise_or_expr)*
    ?bitwise_or_expr: bitwise_xor_expr ("|" bitwise_xor_expr)*
    ?bitwise_xor_expr: bitwise_and_expr ("^" bitwise_and_expr)*
    ?bitwise_and_expr: equality_expr ("&" equality_expr)*
    ?equality_expr: relational_expr (("==" | "!=") relational_expr)*
    ?relational_expr: shift_expr (("<" | ">" | "<=" | ">=") shift_expr)*
    ?shift_expr: additive_expr (("<<" | ">>") additive_expr)*
    ?additive_expr: multiplicative_expr (("+" | "-") multiplicative_expr)*
    ?multiplicative_expr: unary_expr (("*" | "/" | "%") unary_expr)*
    ?unary_expr: ("!" | "~" | "&")* atom

    ?atom: literal
         | CNAME -> identifier
         | "(" expr ")"
         | call_expr

    call_expr: CNAME "(" [arguments] ")"
    arguments: (expr ("," expr)*)?

    ?literal: HEX_NUMBER -> number
            | SIGNED_INT -> number
            | ESCAPED_STRING -> string

    HEX_NUMBER: /0[xX][0-9a-fA-F]+/

    %import common.CNAME
    %import common.SIGNED_INT
    %import common.ESCAPED_STRING
    %import common.WS
    %ignore WS
    %ignore /\/\/[^\n]*/
    %ignore /\/\*(\*(?!\/)|[^*])*\*\//
"""

class IDCTransformer(Transformer):
    """
    Transforms the Lark parse tree. It recursively finds all function calls
    ('call_expr' nodes) and returns them as a flat list, discarding all other
    structural and expression-related elements.
    """
    def __init__(self):
        self.statements = []

    def number(self, n):
        return int(n, 0)

    def string(self, s):
        return s[1:-1].encode('latin-1').decode('unicode_escape')

    def identifier(self, i):
        return str(i)

    def arguments(self, *args):
        return list(args)

    def call_expr(self, func_name, args=None):
        statement_tuple = (str(func_name), args or [])
        self.statements.append(statement_tuple)
        return statement_tuple

    # Default handler for all other rules: traverse children and collect results.
    def __default__(self, data, children, meta):
        # This is a simple way to visit all nodes recursively.
        # We don't need to do anything with the results other than
        # letting the traversal continue down to the `call_expr` nodes.
        # Return children if they exist, otherwise return data
        if children:
            return children
        return data

    def start(self, items):
        # After the entire tree is walked, self.statements will be populated.
        return self.statements

class IDCScriptEngine:
    def __init__(self, db: AnalysisDatabase):
        self.db = db
        self.function_map = self._initialize_function_map()

    def _initialize_function_map(self):
        return {
            "create_insn": self.idc_create_insn, "create_byte": lambda a: self.idc_create_data(a, 1),
            "create_word": lambda a: self.idc_create_data(a, 2), "create_dword": lambda a: self.idc_create_data(a, 4),
            "create_strlit": self.idc_create_ascii, "set_name": self.idc_set_name, "set_cmt": self.idc_set_cmt,
            "add_func": self.idc_add_func, "op_hex": lambda a, n: self.idc_op_format(a, n, 'hex'),
            "op_dec": lambda a, n: self.idc_op_format(a, n, 'dec'), "op_offset": self.idc_op_offset,
            "op_plain_offset": self.idc_op_offset, "add_segm_ex": self.idc_add_segm_ex,
            **{k: self.idc_no_op for k in ["update_extra_cmt", "set_frame_size", "define_local_var", "op_enum",
            "op_stroff", "op_stkvar", "op_seg", "SegRename", "SegClass", "SegDefReg", "set_segm_type",
            "split_sreg_range", "delete_all_segments", "add_enum", "add_enum_member", "add_struc", "add_struc_member",
            "get_struc_id", "get_member_id", "SetType", "set_struc_align", "set_processor_type", "set_inf_attr",
            "set_flag", "add_default_til", "begin_type_updating", "end_type_updating", "make_array", "get_inf_attr", "GetEnum"]}
        }

    def idc_no_op(self, *args, **kwargs): return 0
    def idc_create_insn(self, addr):
        if info := self.db.get_address_info(addr): info.item_type = ITEM_TYPE_CODE
    def idc_create_data(self, addr, size):
        for i in range(size):
            if info := self.db.get_address_info(addr + i):
                info.item_type = ITEM_TYPE_DATA
                if i == 0:
                    info.item_size = size
                    if size == 4: info.data_type = DATA_TYPE_DWORD
                    elif size == 2: info.data_type = DATA_TYPE_WORD
                    else: info.data_type = DATA_TYPE_BYTE
    def idc_create_ascii(self, addr, length):
        if length == 0:
            curr_addr, length = addr, 0
            while True:
                info = self.db.get_address_info(curr_addr); length += 1
                if not info or info.byte_value == 0: break
                curr_addr += 1
        if info := self.db.get_address_info(addr):
            info.item_type, info.item_size, info.data_type = ITEM_TYPE_DATA, length, DATA_TYPE_ASCII
        for i in range(1, length):
            if info_rest := self.db.get_address_info(addr + i): info_rest.item_type, info_rest.data_type = ITEM_TYPE_DATA, DATA_TYPE_ASCII
    def idc_set_name(self, addr, name, *args):
        if info := self.db.get_address_info(addr): info.label = name
    def idc_set_cmt(self, addr, comment, repeatable=0, *args):
        is_repeatable = bool(int(repeatable)) if str(repeatable).isdigit() else False
        if info := self.db.get_address_info(addr):
            if is_repeatable: info.repeatable_comment = comment
            else: info.comment = comment
    def idc_op_format(self, addr, op_index, fmt_type): self.db.operand_format_overrides[(addr, op_index)] = OperandFormat(fmt_type)
    def idc_op_offset(self, addr, op_index, base): self.db.operand_format_overrides[(addr, op_index)] = OperandFormat('offset', base)
    def idc_add_func(self, start_addr, end_addr): self.db.add_function(start_addr, end_addr)
    def idc_add_segm_ex(self, start, end, base, use32, name, sclass, *args):
        new_seg = Segment(name, start, end, base, str(sclass) if sclass else "CODE", bool(use32))
        if not self.db.get_segment_by_selector(base): self.db.segments.append(new_seg)

    def execute_script(self, filepath: str):
        logger.info(f"Executing IDC script: {filepath}")
        func_call_pattern = re.compile(r'(\w+)\(([^)]*)\);')
        try:
            with open(filepath, 'r', encoding='latin-1') as f:
                line_num = 0
                for line in f:
                    line_num += 1
                    if line.strip().startswith(('//', '#', '/*')) or not line.strip(): continue
                    for match in func_call_pattern.finditer(line):
                        func_name, args_str = match.group(1), match.group(2)
                        if func_name in self.function_map:
                            args = []
                            for arg_str in [a.strip() for a in args_str.split(',') if a.strip()]:
                                if arg_str.startswith(('0x', '0X')): args.append(int(arg_str, 16))
                                elif arg_str.isdigit() or (arg_str.startswith('-') and arg_str[1:].isdigit()): args.append(int(arg_str))
                                elif arg_str.startswith('"') and arg_str.endswith('"'): args.append(arg_str[1:-1])
                                else: args.append(arg_str)
                            try: self.function_map[func_name](*args)
                            except Exception as e: logger.warning(f"IDC Warning (line {line_num}): Error in '{func_name}({args})': {e}")
        except Exception as e:
            logger.error(f"Fatal error processing IDC script: {e}")
